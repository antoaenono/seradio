---
author: @antoaenono
asked: 2026-02-18
decided: 2026-02-18
status: proposed
deciders: @antoaenono
tags: [scheduler, queue, sizing, hls]
parent: scheduler/playout
children: []
---

# ADR: Segment Duration and Window Size

## Scenario

What segment duration and window size should we use for the HLS stream?

## Pressures

### More

1. [M1] Resilience to network jitter
2. [M2] Smooth playback
3. [M3] Low latency
4. [M4] Playback feels "live"

### Less

1. [L1] Server tick overhead
2. [L2] Client-side complexity
3. [L3] Disk usage

## Chosen Option

1-second segments with a window of 3. The spec minimum: 3 segments x 1s TARGETDURATION = 3s of buffered audio.

## Artistic

"Tightrope with a net."

## Why

In the context of **choosing segment duration and window size for the HLS stream**,
facing **the tradeoff between latency and resilience**,
we decided **to use 1-second segments with a window of 3 (the HLS spec minimum)**,
to achieve **the lowest possible latency while remaining spec-compliant, with playback that feels live**,
accepting **high tick rate (1 tick/second), more HTTP requests from clients, and less buffer against network hiccups**.

## Points

### For

- [M3] 1-second segments mean a listener is at most ~3 seconds behind live
- [M4] Tight window makes playback feel immediate, like tuning into a real radio
- [M2] 3 segments is the HLS spec minimum, so hls.js and native players handle it correctly
- [M1] 3 seconds of buffer is enough for most stable connections

### Against

- [L1] Tick fires every second, writing a new playlist each time
- [M1] Only 3 seconds of buffer - a network stall longer than ~2s causes a playback gap
- [L2] Client polls every TARGETDURATION (1s), high request rate
- [L3] More segment files on disk per track (a 5-minute track = ~300 .ts files)
- [M2] More segment boundaries means more potential for tiny audio glitches at joins

## Consequences

- [latency] ~3 seconds behind live (lowest possible for standard HLS)
- [tick-rate] 1 tick per second, 1 playlist write per second
- [disk] ~300 .ts files per 5-minute track (cleaned up as consumed)
- [bandwidth] Client makes ~1 HTTP request per second for segments
- [sync] All listeners within ~3 seconds of each other

## How

```ts
export const SEGMENT_DURATION = 1
const WINDOW_SIZE = 3
```

ffmpeg segments at 1-second boundaries:

```
ffmpeg -i track.mp3 -codec:a aac -b:a 128k \
  -f segment -segment_time 1 \
  segments/t0_%03d.ts
```

Playlist always contains 3 entries, TARGETDURATION is 1:

```
#EXTM3U
#EXT-X-TARGETDURATION:1
#EXT-X-MEDIA-SEQUENCE:47
#EXTINF:1.000000,
/api/audio/segments/t0_047.ts
#EXTINF:1.000000,
/api/audio/segments/t0_048.ts
#EXTINF:1.000000,
/api/audio/segments/t0_049.ts
```

## Reconsider

- observe: Clients on poor connections frequently stall
  respond: Increase window size to 6 or increase segment duration to buffer more
- observe: Server CPU is noticeably busy from tick overhead
  respond: Move to 2s or 6s segments to reduce tick frequency

## History

1-second segments are at the aggressive end of the HLS spectrum. Apple's original recommendation was 10 seconds, later revised to 6 seconds. Low-Latency HLS (LL-HLS) achieves sub-second latency not by shrinking segments but by introducing "partial segments" (parts) within standard 6-second segments. Our approach is simpler: just make the segments small.

## More Info

- [RFC 8216 section 6.2.2 - sliding window](https://datatracker.ietf.org/doc/html/rfc8216#section-6.2.2)
- [Apple Developer Forums - HLS recommended segment size](https://developer.apple.com/forums/thread/61411)
- [Bitmovin - MPEG-DASH & HLS segment length](https://bitmovin.com/blog/mpeg-dash-hls-segment-length/)
